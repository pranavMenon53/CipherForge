Note - the following is input the chat GPT to receive feedback and correct any mistakes made.
In various places I have oversimplified few things for easier understanding.

I'm learning about HTTPS, specifically TLS 1.2.
​
	I have the following understand of it, correct me if I'm wrong.
​
	1. First, the client and the server perform a TLS handshake.
	2. As part of this handshake, few pieces of information are propagated between the client and the server.
		a. Note - Only the initial handshake messages are unencrypted.
			i. Only ClientHello, ServerHello, and the server's Certificate are in plaintext. If using DHE or ECDHE, a ServerKeyExchange message is also sent in plaintext.
			ii. Once the keys are exchanged, a changeCipherSpec message is exchanged to indicate that any further communication will be encrypted.
			iii. The transition to encrypted communication happens after the session keys are established.
		b. Client and server decide on a cipher suite.
			i. The cipher suite contains information about all the algorithms needed to achieve the objectives of TLS - confidentiality, integrity, and authenticity.
		c. Creation of client random and server random strings.
		d. Exchange of server certificate (client also sends its certificate if MTLS is enabled)
			i. The certificate contains few crucial pieces of information.
			ii. Server public key
			iii. certificate details such as issuer, validity, hashing algorithm used by the CA to sign the certificate, encryption algorithm used by the CA for encrypting the digital signature, etc.
	3. 	Once the server certificate is available with the client, it can use it to validate whether the server is legitimate or an imposter.
		a. The client creates a hash of its own using the details present in the certificate, everything except the digital signature.
		b. The hashing algorithm is mentioned in the server's certificate. Let's call the hash generated by this algorithm as H1.
		c. The client then uses the CAs public key to decrypt the digital signature and get the hash generated by the CA - call it H2.
		d. If H1 == H2, then we know the server is legitimate.
		e. Also, the client must validate the certificate chain (checking CA trust, expiry, revocation, etc.), not just match hashes.
		f. The client also performs certificate chain validation, expiry checks, hostname matching, and revocation checks (CRL/OCSP), not just a hash match.
	4. Once the server is verified to be legitimate, we now need to generate a session key (AKA master secret) used for symmetric encryption of the bulk messages.
		a. The generation of the session key depends on the algorithm used.
		b. This is communicated in the cipher suite.
		c. In RSA based algorithms, a pre-master key (generated by the client) is shared to the server after being encrypted by the server's public key.
			i. RSA key exchange is now deprecated in favor of DHE/ECDHE due to forward secrecy concerns.
			ii. DHE/ECDHE is used in 1.3 and can also be used in TLS 1.2 instead of RSA.
			iii. Note that DHE/ECDHE is now the standard used even for TLS 1.2.
			iv. We discuss RSA as the initial stepping stone to understanding TLS.
		d. In algorithms like DHE and ECDHE, there is no such transmission. Each party is responsible for generating the session keys.
		e. For the sake of this summary, I will go with RSA based master key generation.
		f. Here, we have the following steps -
			i. Client creates a pre-master secret.
			ii. This secret is shared to the server after being encrypted by the server's public key.
			iii. Now, both the client and the server have the pre-master secret.
			iv. They use this pre-master secret, along with client random and server random, and some other information to generate a "key block".
			v. This key block contains client_write_key, server_write_key, and other pieces of information.
			vi. Why do we have 2 separate write keys?
			vii. This is because HTTP/2 supports full duplex.
			viii. This means that both the client and the server can initiate the conversation and send messages.
			ix. When the client sends messages to the server, it uses the client_write_key to encrypt the messages.
			ix. When the server sends messages to the client, it uses the server_write_key to encrypt the messages.
		g. Once the client_write_key and server_write_key have been derived independently by both the client and the server, we must validate them.
			a. This verification uses a PRF (Pseudo-Random Function), derived from:
				i. The master secret
				ii. The transcript (all handshake messages so far — ClientHello, ServerHello, Certificate, etc.)
				iii. A constant label string like "client finished" or "server finished".
				iv. For the client:
						verify_data =
							PRF(
									master_secret,
									"client finished",
									Hash(handshake_messages)
								)

				v. For the server:
						verify_data =
							PRF(
									master_secret,
									"server finished",
									Hash(handshake_messages)
								)

				vii. handshake_messages = all previous handshake messages in order, concatenated

				viii. verify_data = first 12 bytes of the PRF output, sent as proof

			b. Let’s assume this scenario:
				i. Master Secret: 4A 5B 6C 7D 8E 9F A1 B2 C3 D4 E5 F6 A7 B8 C9 D0

				ii. Handshake Transcript (simplified): (This is hashed, e.g., with SHA-256)
						ClientHello
						ServerHello
						Certificate
						ServerHelloDone
						ClientKeyExchange
						ChangeCipherSpec

				iii. Operations done by the client -
						i. Concatenates all handshake messages.
						ii. Hashes them using the negotiated hash (say, SHA-256):

								transcript_hash = SHA256(all_handshake_messages)
								→ transcript_hash = a94f...98cd

						iii. Runs the PRF:

								verify_data = PRF(master_secret, "client finished", transcript_hash)
								→ verify_data = 12-byte value: ab 34 cd 56 ef 78 90 12 34 56 ab cd

						iv. Sends verify_data inside an encrypted Finished message.

				iv. Operations done by the server -

					i. Recomputes the same transcript hash (it has the same handshake messages).
					ii. Runs the PRF using its own copy of master_secret:

							verify_data_server = PRF(master_secret, "client finished", transcript_hash)
							→ It matches ab 34 cd 56 ef 78 90 12 34 56 ab cd.
					iii. If it matches, the server knows:

							i. The master secret matches
							ii. The transcript wasn’t tampered with

					iv. Server then sends its own Finished message, labeled "server finished".

			c.  Why This Is Important
					i. Integrity: Detects any tampering with handshake messages.

					ii. Key confirmation: Confirms both client and server derived identical keys from the handshake.

					iii. MitM protection: If a man-in-the-middle modified anything during the handshake, the transcript hash would differ, and the handshake would fail.

	This is the whole TLS process for TLS 1.2.
	Provide feedback on the information shared.