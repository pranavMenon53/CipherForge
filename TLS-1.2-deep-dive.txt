Note - the following is input the chat GPT to receive feedback and correct any mistakes made.
In various places I have oversimplified few things for easier understanding.

I'm learning about HTTPS, specifically TLS 1.2.
TLS 1.2 using RSA has been deprecated, however it is a good starting point to learn about TLS.
TLS 1.3 removes RSA key transport entirely.
RSA, DHE, and ECDHE are key exchange algorithms.
RSA is used only for key transport in RSA-based handshakes.
DHE/ECDHE are key exchange algorithms for securely establishing the shared secret.
(ECDHE) provides forward secrecy.

​
	I have the following understanding of it, correct me if I'm wrong.
​
	1. First, the client and the server perform a TLS handshake.

	2. As part of this handshake, few pieces of information are propagated between the client and the server.

		a. Note - Only the initial handshake messages are unencrypted.

			i. Only ClientHello, ServerHello, and the server's Certificate are in plaintext.
				- If using DHE or ECDHE, a ServerKeyExchange message is also sent in plaintext.

			ii. Once the keys are exchanged, a changeCipherSpec message is exchanged to indicate that any further communication will be encrypted.

			iii. After ChangeCipherSpec, each side starts encrypting subsequent handshake messages, including the Finished message.

			iv. Before that point, all handshake traffic is in plaintext.

			v. The transition to encrypted communication happens after the session keys are established.

		b. Client and server decide on a cipher suite.

			i. The cipher suite contains information about all the algorithms needed to achieve the objectives of TLS - confidentiality, integrity, and authenticity.

		c. Creation of client random and server random strings.

		d. Exchange of server certificate (client also sends its certificate if MTLS is enabled)

			i. The certificate contains few crucial pieces of information.

			ii. Server public key

			iii. certificate details such as issuer, validity, hashing algorithm used by the CA to sign the certificate, encryption algorithm used by the CA for encrypting the digital signature, etc.

			iv. The certificate is issued by a 3rd party entity called as the certificate authority (CA).

	3. 	Once the server certificate is available with the client, it can use it to validate whether the server is legitimate or an imposter.

		a. The client creates a hash of its own using the details present in the certificate, everything except the digital signature.

		b. The hashing algorithm is mentioned in the server's certificate. Let's call the hash generated by this algorithm as H1.

		c. The client then uses the CAs public key to decrypt the digital signature and get the hash generated by the CA - call it H2.

		d. If H1 == H2, then we know the server is legitimate.

		e. Also, the client must validate the certificate chain (checking CA trust, expiry, revocation, etc.), not just match hashes.

		f. The client also performs certificate chain validation, expiry checks, hostname matching, and revocation checks (CRL/OCSP), not just a hash match.

	4. Once the server is verified to be legitimate, we now need to generate a master secret used for symmetric encryption of the bulk messages.

		a. The generation of the master secret depends on the algorithm used.

		b. This is communicated in the cipher suite.

		c. In RSA based algorithms, a pre-master key (generated by the client) is shared to the server after being encrypted by the server's public key.

			i. RSA key exchange is now deprecated in favor of DHE/ECDHE due to forward secrecy concerns.

			ii. DHE/ECDHE is used in 1.3 and can also be used in TLS 1.2 instead of RSA.

			iii. Note that DHE/ECDHE is now the standard used even for TLS 1.2.

			iv. We discuss RSA as the initial stepping stone to understanding TLS.

		d. In algorithms like DHE and ECDHE, there is no such transmission. Each party is responsible for generating the session keys.

		e. For the sake of this summary, I will go with RSA based master key generation.

		f. Here, we have the following steps -

			i. Client creates a pre-master secret.

			ii. This secret is shared to the server after being encrypted by the server's public key.

			iii. Now, both the client and the server have the pre-master secret.

			iv. They use this pre-master secret, along with client random and server random, and some other information to generate a "key block".

			v. This key block contains client-write-key, server-write-key, client_mac_key, server_mac_key and other pieces of information.

			vi. Why do we have 2 separate write keys?

			vii. This is because HTTP/2 supports full duplex.

			viii. This means that data can flow in both directions (client -> server) and (server -> client).

			ix. When the client sends messages to the server, it uses the client-write-key to encrypt the messages.

			ix. When the server sends messages to the client, it uses the server-write-key to encrypt the messages.

		g. Once the client-write-key and server-write-key have been derived independently by both the client and the server, we must validate them.

			a. This verification uses a PRF (Pseudo-Random Function), derived from:

				i. The master secret

				ii. The transcript (all handshake messages so far — ClientHello, ServerHello, Certificate, etc.)

				iii. A constant label string like "client finished" or "server finished".

				iv. For the client:
						verify_data =
							PRF(
									master_secret,
									"client finished",
									Hash(handshake_messages)
								)

				v. For the server:
						verify_data =
							PRF(
									master_secret,
									"server finished",
									Hash(handshake_messages)
								)

				vii. handshake_messages = all previous handshake messages in order, concatenated

				viii. verify_data = first 12 bytes of the PRF output, sent as proof

			b. Let’s assume this scenario:
				i. Master Secret: 4A 5B 6C 7D 8E 9F A1 B2 C3 D4 E5 F6 A7 B8 C9 D0

				ii. Handshake Transcript (simplified): (This is hashed, e.g., with SHA-256)
						ClientHello
						ServerHello
						Certificate
						ServerHelloDone
						ClientKeyExchange
						ChangeCipherSpec

				iii. Operations done by the client -
						i. Concatenates all handshake messages.

						ii. Hashes them using the negotiated hash (say, SHA-256):

								transcript_hash = SHA256(all_handshake_messages)

								→ transcript_hash = a94f...98cd

						iii. Runs the PRF:

								verify_data = PRF(master_secret, "client finished", transcript_hash)

								→ verify_data = 12-byte value: ab 34 cd 56 ef 78 90 12 34 56 ab cd

						iv. Sends verify_data inside an encrypted Finished message.

						v. The client takes its verify_data (first 12 bytes of PRF output) and encrypts it using the client-write-key

				iv. Operations done by the server -

					i. Recomputes the same transcript hash (it has the same handshake messages).

					ii. It decrypts the verify_data sent by the client using the client-write-key

					ii. Runs the PRF using its own copy of master_secret:

							verify_data_server = PRF(master_secret, "client finished", transcript_hash)

							→ It matches ab 34 cd 56 ef 78 90 12 34 56 ab cd.

					iii. If it matches, the server knows:

							i. The master secret matches
							ii. The transcript wasn’t tampered with

					iv. Server then sends its own Finished message, labeled "server finished".

			c.  Why This Is Important

					i. Integrity: Detects any tampering with handshake messages.

					ii. Key confirmation: Confirms both client and server derived identical keys from the handshake.

					iii. MitM protection: If a man-in-the-middle modified anything during the handshake, the transcript hash would differ, and the handshake would fail.

			d. Example

				Suppose client-write-key = abc123...

				Client sends:

					Encrypted_Finished = AES_Encrypt(abc123..., ab 34 cd 56 ef 78 90 12 34 56 ab cd)

				Server:

					verify_data_received = AES_Decrypt(abc123..., Encrypted_Finished)

					verify_data_expected = PRF(master_secret, "client finished", transcript_hash)

				If verify_data_received == verify_data_expected

					The server accepts the handshake and sends its own encrypted Finished message back using the server-write-key.

	5. Flow -
		| Step | Message                                                  | Encryption Status                     |
		| ---- | -------------------------------------------------------- | ------------------------------------- |
		| 1    | ClientHello                                              | Plaintext                             |
		| 2    | ServerHello                                              | Plaintext                             |
		| 3    | Certificate                                              | Plaintext                             |
		| 4    | ServerHelloDone                                          | Plaintext                             |
		| 5    | ClientKeyExchange (contains encrypted pre-master secret) | Plaintext (RSA-encrypted secret)      |
		| 6    | \[Key Derivation Happens Here]                           | —                                     |
		| 7    | ChangeCipherSpec (client → server)                       | Plaintext                             |
		| 8    | Finished (client → server)                               | **Encrypted with client\_write\_key** |
		| 9    | ChangeCipherSpec (server → client)                       | Plaintext                             |
		| 10   | Finished (server → client)                               | **Encrypted with server\_write\_key** |

	6. What we've covered so far is the TLS handshake.

		- The handshake takes care of the confidentiality and authenticity aspect of TLS.

		- However, integrity is not yet discussed.

		- Integrity occurs during the hash validation for authentication but let's discuss it in terms of data transfer.

		- Confidentiality during data transfer is achieved via symmetric encryption.
			a.	Achieved using symmetric encryption (like AES, ChaCha20).
			b.	Keys used: client-write-key and server-write-key, derived from the master secret.
			c.	Reason: Symmetric encryption is fast and efficient for bulk data transfer.

		- Authentication is a combination of -
			a.	symmetric cryptography (RSA, ECDHE, etc.) for secure key exchange.
			b.	Digital certificates issued by a trusted Certificate Authority (CA) to prove the server’s identity.
			c.	Digital signatures to verify that the server (and optionally the client) owns the private key in the certificate.
			d.	Hashing (like SHA-256) to sign and verify handshake messages without tampering.

		- But how is integrity achieved?

		- Integrity in TLS just means: making sure that the data you receive is exactly what was sent, with no tampering or accidental changes.

		- Before sending the data, a digital fingerprint of the message is created and added to the cipher text.
			- MAC_input = seq_num || content_type || version || length || plaintext
			- MAC = HMAC_SHA256(client_mac_key, message_data)

		- This MAC is then used to create a text which is then encrypted using the client-write-key.
			- (plaintext || MAC || padding) → ENCRYPTED → ciphertext

			- What is padding?
				- Well, the AES is a block cipher.
				- It operates in 16 bytes block size.
				- padding_length = block_size - ((len(plaintext + MAC)) % block_size) - 1
				- If a perfect block for plain text + mac, we add another 16 bytes to represent padding.
				- If plaintext + MAC = 35 bytes then the padding added is for 13 bytes because the next block size is 48.

		- The server uses the client-write-key (symmetric key) to decrypt the ciphertext.

		- After decryption, the server sees the original concatenated structure:
			- plaintext || MAC || padding

		- Remove the padding - The server checks the last byte of the decrypted message to know how many padding bytes were added.

		- Separate the MAC - The MAC is a fixed length (depends on the cipher suite — e.g., 20 bytes for SHA-1, 32 for SHA-256).
			- So the server knows exactly how many bytes at the end of the message represent the MAC.

		- At this point, it has all the pieces of information extracted.

		- The server then recomputes the MAC using:

				The client_write_MAC_key

				The plaintext

				Metadata like the TLS record sequence number, message type, and length

		- Verify

				Compare the recomputed MAC with the extracted MAC:

				If they match → message is authentic and untampered.

				If not → terminate the session with an error.


	This is the whole TLS process for TLS 1.2.
	Provide feedback on the information shared.
