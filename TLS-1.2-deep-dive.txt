Note - the following is input the chat GPT to receive feedback and correct any mistakes made.
In various places I have oversimplified few things for easier understanding.

I'm learning about HTTPS, specifically TLS 1.2.
​
	I have the following understand of it, correct me if I'm wrong.
​
	1. First, the client and the server perform a TLS handshake.
	2. As part of this handshake, few pieces of information are propagated between the client and the server.
		a. Note - Only the initial handshake messages (ClientHello, ServerHello, Certificate) are unencrypted.
			i. The rest of the communication is encrypted.
			ii. Messages like Finished are encrypted using the derived keys.
			iii. The transition to encrypted communication happens after the session keys are established.
		b. Client and server decide on a cipher suite.
			i. The cipher suite contains information about all the algorithms needed to achieve the objectives of TLS - confidentiality, integrity, and authenticity.
		c. Creation of client random and server random strings.
		d. Exchange of server certificate (client also sends its certificate if MTLS is enabled)
			i. The certificate contains few crucial pieces of information.
			ii. Server public key
			iii. certificate details such as issuer, validity, hashing algorithm used, encryption algorithm used, etc.
			iv. Digital signature signed by the CA
	3. 	Once the server certificate is available with the client, it can use it to validate whether the server is legitimate or an imposter.
		a. The client creates a hash of its own using the details present in the certificate, everything except the digital signature.
		b. Let's call this hash as H1.
		c. The client then uses the CAs public key to decrypt the digital signature and get the hash generated by the CA - call it H2.
		d. If H1 == H2, then we know the server is legitimate.
	4. Once the server is verified to be legitimate, we now need to generate a session key (AKA master key) used for symmetric encryption of the bulk messages.
		a. The generation of the session key depends on the algorithm used.
		b. This is communicated in the cipher suite.
		c. In RSA based algorithms, a pre-master key (generated by the client) is shared to the server after being encrypted by the server's public key.
		d. In algorithms like DHE and ECDHE, there is no such transmission. Each party is responsible for generating the session keys.
		e. For the sake of this summary, I will go with RSA based master key generation.
		f. Here, we have the following steps -
			i. Client creates a pre-master secret.
			ii. This secret is shared to the server after being encrypted by the server's public key.
			iii. Now, both the client and the server have the pre-master secret.
			iv. They use this pre-master secret, along with client random and server random, and some other information to generate a "key block".
			v. This key block contains client_write_key, server_write_key, and other pieces of information.
			vi. Why do we have 2 separate write keys?
			vii. This is because HTTP/2 supports full duplex.
			viii. This means that both the client and the server can initiate the conversation and send messages.
		g. Once the client_write_key and server_write_key have been derived independently by both the client and the server, we must validate them.
			a. The client takes all the messages exchanged during the handshake and creates a hash of it.
			b. This hash is then encrypted using the client_write_key - let's call this hash H3.
			c. This hash is then sent to the server.
			d. The server does the same on its end, it takes all the messages exchanged during the handshake and creates a hash of it - call it H4.
			e. Once the server receives the encrypted H3 hash from the client, it uses the client_write_key derived by it to decrypt the message.
			f. The decrypted message will contain a hash - call it h5.
			g. IF h5 == h4, then the server knows the client_write_key works perfectly.
			h. Similarly, they verify the server_write_key.
			i. these messages are called as "Finished" to indicate the finalization of the TLS handshake.

	This is the whole TLS process.
	Provide feedback on the information shared.